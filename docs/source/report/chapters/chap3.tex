\section{QEMU Overview}

QEMU (Quick Emulator) is an open-source virtualization technology that allows users to run operating systems and applications for one architecture on a different architecture. It achieves this by emulating the hardware of the target architecture, enabling software designed for that architecture to run seamlessly on the host system. QEMU supports a wide range of architectures, including x86, ARM, PowerPC, and MIPS, making it a versatile tool for developers and testers.

Rather than introducing how QEMU works, this section will focus on the components of QEMU that are relevant to our project. For a comprehensive understanding of QEMU's architecture and functionality, readers are encouraged to refer to the official QEMU documentation and other detailed resources \href{https://qemu.readthedocs.io/en/v9.0.4/}{QEMU v9.0.4}.

\subsection{QEMU Object Model - QOM}
The QEMU Object Model (QOM) is a framework within QEMU that provides a structured way to define and manage the various components and devices that make up a virtual machine. It allows for the creation of complex device hierarchies and relationships, enabling modularity and reusability of code.
QOM is built around the concept of ``objects'', which represent different components of the virtual machine, such as CPUs, memory, and peripherals. Each object can have properties, methods, and events associated with it, allowing for dynamic behavior and interaction between components.
QOM provides a set of macros and functions that simplify the process of defining new device types and their interactions. It also supports inheritance, allowing new device types to extend existing ones, promoting code reuse and reducing duplication.
In our project, we utilize QOM to define custom devices and their interactions within the virtual machine. This allows us to create a tailored environment that meets our specific requirements while leveraging the existing infrastructure provided by QEMU.

This concept of objects is made possible via two main functions registered in the object class:
\begin{itemize}
    \item \textbf{\mintinline{c}|init()| - Registration:} This function allows developers to register new object types with QEMU. Each type is defined by a unique name and a set of properties and methods that describe its behavior. This registration process enables QEMU to recognize and manage the new object type within the virtual machine.
    \item \textbf{\mintinline{c}|realize()| - Instance Creation:} Once an object type is registered, instances of that type can be created using this function. Each instance represents a specific occurrence of the object type, with its own state and configuration. This allows for multiple instances of the same object type to coexist within the virtual machine, each with its own unique characteristics.
\end{itemize}

\subsection{Device Emulation}
QEMU supports the emulation of a large number of devices from peripherals such network cards and USB devices to integrated systems on a chip (SoCs). Configuration of these is often a source of confusion so it helps to have an understanding of some of the terms used to describes devices within QEMU: 
\begin{itemize}
    \item \textbf{Device Frontend:} A device front end is how a device is presented to the guest. The type of device presented should match the hardware that the guest operating system is expecting to see. All devices can be specified with the --device command line option. Running QEMU with the command line options --device help will list all devices it is aware of. Using the command line --device foo,help will list the additional configuration options available for that device.
    A front end is often paired with a back end, which describes how the hostâ€™s resources are used in the emulation. 
    \item \textbf{Device Bus:} Most devices will exist on a BUS of some sort. Depending on the machine model you choose (-M foo) a number of buses will have been automatically created. In most cases the BUS a device is attached to can be inferred, for example PCI devices are generally automatically allocated to the next free address of first PCI bus found. However in complicated configurations you can explicitly specify what bus (bus=ID) a device is attached to along with its address (addr=N).
    \item \textbf{Device Backend:} The back end describes how the data from the emulated device will be processed by QEMU. The configuration of the back end is usually specific to the class of device being emulated. For example serial devices will be backed by a --chardev which can redirect the data to a file or socket or some other system. Storage devices are handled by --blockdev which will specify how blocks are handled, for example being stored in a qcow2 file or accessing a raw host disk partition. Back ends can sometimes be stacked to implement features like snapshots. 
\end{itemize}


\section{Testing and Conclusion}\label{sec:testing_conclusion}

In this section we discuss how to compile and run both QEMU and FreeRTOS on the NXP board.

\subsection{QEMU Compilation and Execution}

To compile QEMU with support for the NXP board, follow these steps:
\begin{enumerate}
    \item {Clone the QEMU repository:
    \begin{minted}{bash}
        $ git clone https://baltig.polito.it/eos2024/group10
      \end{minted}
    }
    \item {Navigate to the buld directory:
    \begin{minted}{bash}
        $ cd qemu/build/
      \end{minted}
    }
    \item {Run the configuration script:
    \begin{minted}{bash}
        $ ../configure --target-list=arm-softmmu
      \end{minted}
    }
    \item {Compile QEMU:
    \begin{minted}{bash}
        $ make -j$(nproc)
      \end{minted}
    }
    \item {Run QEMU with the NXP board:
    \begin{minted}{bash}
        $ ./qemu/build/qemu-system-arm -machine S32K3X8EVB -monitor stdio -m 128M -nographic
      \end{minted}
    }
\end{enumerate}

\subsection{FreeRTOS Compilation and Execution}

To port FreeRTOS to the NXP board, the NXP toolchain has been used and it is included with the repository in the \texttt{gcc-10.2.0-Earmv7GCC-eabi} directory.

To compile FreeRTOS for the NXP board a Makefile is provided in the FreeRTOS\_App directory. The Makefile is configured to use the NXP toolchain and includes paths to the FreeRTOS kernel and the peripheral drivers.

To compile and run FreeRTOS, follow these steps:
\begin{enumerate}
    \item {Clone the FreeRTOS repository:
    \begin{minted}{bash}
        $ git clone https://github.com/FreeRTOS/FreeRTOS.git --recurse-submodules
      \end{minted}
    }
    \item {Navigate to the FreeRTOS directory:
    \begin{minted}{bash}
        $ cd FreeRTOS_App
      \end{minted}
    }
    \item {Compile FreeRTOS:
    \begin{minted}{bash}
        $ make
      \end{minted}
    }
    \item {Run FreeRTOS on QEMU:
    \begin{minted}{bash}
        $ make qemu_start
      \end{minted}
    }
\end{enumerate}

At the top of the file the path to the FreeRTOS kernel can be modified in case it is cloned in a different directory. 

\subsubsection{Debugging FreeRTOS with GDB}

A Debug environment is provided to debug FreeRTOS running on the NXP board using GDB. 
To debug FreeRTOS running on the NXP board using GDB, follow these steps:

\begin{enumerate}
    \item {Start QEMU with GDB server:
        \begin{minted}{bash}
            $ make qemu_debug
        \end{minted}
    }
    \item {Open another terminal and navigate to the FreeRTOS directory:
        \begin{minted}{bash}
            $ cd FreeRTOS_App
        \end{minted}
    }
    \item {Connect to the QEMU GDB server:
        \begin{minted}{bash}
            $ make gdb_start
        \end{minted}
    }
\end{enumerate}

The Makefile uses \mintinline{bash}|gdb| as the debugger but depending on your system you might need to use \texttt{gdb-multiarch} instead or in case of RHEL/Fedora a fork of gdb with ARM support. 
It is raccomended to have the \mintinline{bash}|gef| plugin installed to have a better debugging experience (\href{https://github.com/hugsy/gef}{GEF}).

\subsection{Conclusion}
In conclusion, this project successfully demonstrated the porting of FreeRTOS to an NXP board, including the development of necessary peripheral drivers and test tasks. The steps taken to set up the development environment, configure the FreeRTOS kernel, and implement the drivers were crucial in achieving a functional embedded system. The testing phase validated the functionality of the FreeRTOS port and the peripheral drivers, ensuring reliable communication over UART and SPI. This experience has provided valuable insights into embedded systems development and real-time operating systems, laying a solid foundation for future projects in this domain. The successful execution of FreeRTOS on the NXP board opens up opportunities for further enhancements, such as integrating additional peripherals, optimizing task scheduling, and exploring advanced features of FreeRTOS. Overall, this project has been a significant step towards mastering embedded systems and real-time operating systems, and it sets the stage for more complex applications in the future.
